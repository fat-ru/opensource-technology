
    * [相关概念](#相关概念)
      * [镜像](#镜像)
      * [容器](#容器)
      * [Docker](#docker)
      * [k8s](#k8s)
      * [Node](#node)
      * [Pod](#pod)
      * [堆栈](#堆栈)
    * [资料参考链接](#资料参考链接)

### 相关概念

#### 镜像

- 概念

由多层只读文件系统（UnionFS）叠加组成的不可变内容，包含容器运行所需的OS文件，依赖，库，应用程序和元数据

- 镜像结构

镜像包括：多个分层文件系统、元数据、Manifest

**分层文件系统**

每一层都是只读的tar包，层之间通过UnionFS合并
> UnionFS：一种联合文件系统，将只读层叠加成一个统一的文件系统视图（./）

```yaml
Layer 1: base OS (e.g., ubuntu)
Layer 2: 安装依赖库（apt install ...）
Layer 3: 拷贝应用 (COPY . /app)
Layer 4: 设置配置参数
...
Layer N:
```

**元数据包括**：

容器默认启动命令（ENTRYPOINT / CMD）
环境变量（ENV）
工作目录（WORKDIR）
端口（EXPOSE）
卷（VOLUME）
用户（USER）

**Manifest**: 描述镜像的层结构、ID、摘要信息

- 镜像制作

Dockerfile自动构建、基于容器手动制作、从tar rootfs构建

以Dockerfile为例：
定义dockerfile文件
```shell
# 拉取基础镜像，作为底层只读层
FROM python:3.10-slim
# 设置工作目录，等同于在镜像构建层级中执行 mkdir -p /app && cd /app
WORKDIR /app
# 复制构建上下文（build命令所在目录）中的requirements.txt到镜像当前工作目录
# 创建一个新的只读层
COPY requirements.txt .
# 安装requirements.txt中列出的Python依赖包
# 创建一个新的只读层
RUN python -m pip install --no-cache-dir -r requirements.txt
# 将构建上下文（应用程序源码、配置、静态文件等）复制到当前目录
# 创建一个新的只读层
COPY . .
# 运行容器时执行的命令，docker run执行时可重新指定命令对下面的命令进行覆盖
CMD ["python", "main.py"]
```

**注意**：按照易变化的程度从低到高构建只读层，可以充分使用换层，提高容器重启的效率。

构建镜像
```shell
docker build -t myapp:v1 .
```


#### 容器

容器是运行单个应用进程的轻量级沙箱
操作系统级别的进程隔离，把程序及其运行时依赖打包在一起。

容器和镜像的关系：
> 镜像是只读模版，容器是镜像启动后的实例
> 容器 = 镜像层（只读） + 容器层（可写）



#### Docker

Docker是一个容器化平台和工具集，是构建、打包、运行容器的工具链与运行时。
> 容器运行时：负责创建、运行、停止容器的软件组成，容器底层引擎。
具体而言：负责将应用程序及依赖包打包成镜像并在主机上以容器形式运行。

#### k8s

k8s是对大规模容器进行编排、管理、调度的分布式系统
具体而言：负责部署、扩容、缩容、发现、滚动更新、自愈

**k8s和docker的关系**：
通常CI使用docker构建镜像，k8s在集群上调度这些镜像。
k8s和docker是常见搭配，但由于k8s支持多种容器运行时，因此不是唯一搭配


#### Node

运行pod的物理机或虚拟机。

- 控制平面节点

运行kube-apiserver、scheduler、cpntroller-manager，负责调度和集群管理。

- 工作节点

运行kubectl、容器运行时、kube-proxy，真正承载pod


#### Pod

pod是k8s的最小调度单元，pod引用镜像并运行容器。

pod和容器的关系：一个或多个容器组成一个pod（实际业务需要多个容器协作运行）


#### 堆栈

为实现某一业务功能所需的一组服务于基础设施组件的组合。


### 资料参考链接
> [Docker官网地址](https://www.docker.com/#)  
> [Docker镜像仓库](https://hub.docker.com/)  
